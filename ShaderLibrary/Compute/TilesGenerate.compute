#pragma kernel TilesGenerate

#define MAX_LIGHTS_PER_TILE 32
#define MAX_LIGHTS_COUNT 1024

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.barkar.bsrp/ShaderLibrary/UnityInput.hlsl"


#define TILE_SIZE 16
#define THREADS_COUNT 256

Texture2D<float> _DepthTexture : register(t1);
RWStructuredBuffer<uint> _RWTileLightsIndicesBuffer : register(u1);
RWStructuredBuffer<uint> _RWTileLightsArgsBuffer : register(u2);

float4 _DeferredTileParams;
//float4x4 _viewMatrix;

uniform float3 _CameraNearPlaneLB; //left bottom pos
uniform float3 _CameraNearBasisH; //x
uniform float3 _CameraNearBasisV; //y


groupshared uint tileVisibleLightsIndices[MAX_LIGHTS_COUNT];
groupshared uint tileVisibleLightCount = 0;
groupshared uint tileMinDepthInt = 0xFFFFFFFF;
groupshared uint tileMaxDepthInt = 0;

bool IntersectAABB(float4 aabb, float4 lightSphere) {
    float2 p = aabb.xy + aabb.zw * sign(lightSphere.xy - aabb.xy);
    float2 d = p - lightSphere.xy;
    return dot(d, d) < lightSphere.w * lightSphere.w;
}

bool Intersect(float3 tileFrustumCorners[4], float4 lightSphere) {
    float tileDepthMin = asfloat(tileMinDepthInt);
    float tileDepthMax = asfloat(tileMaxDepthInt);
    float lightRadius = lightSphere.w;
    float lightDepthMin = lightSphere.z - lightRadius;
    float lightDepthMax = lightSphere.z + lightRadius;
    if (lightDepthMin > tileDepthMax || lightDepthMax < tileDepthMin) {
        return false;
    }

    float minZ = max(tileDepthMin, lightDepthMin);
    float maxZ = min(tileDepthMax, lightDepthMax);
    float farPlaneScale = maxZ / tileDepthMin;
    float nearPlaneScale = minZ / tileDepthMin;
    float2 minXY = tileFrustumCorners[0].xy;
    float2 maxXY = tileFrustumCorners[2].xy;
    minXY = min(minXY * nearPlaneScale, minXY * farPlaneScale);
    maxXY = max(maxXY * nearPlaneScale, maxXY * farPlaneScale);
    float4 aabb = float4((minXY + maxXY) * 0.5, (maxXY - minXY) * 0.5);
    return IntersectAABB(aabb, lightSphere);
}

[numthreads(TILE_SIZE, TILE_SIZE, 1)]
void TilesGenerate(uint3 id: SV_DispatchThreadID, uint3 groupId : SV_GROUPID, uint groupIndex: SV_GROUPINDEX)
{
    bool onScreen = (float)id.x < _ScreenParams.x && float(id.y) < _ScreenParams.y;
    float depth = 0;
    float linearDepth = 0;
    if(onScreen)
    {
        depth = _DepthTexture[id.xy].r;
        linearDepth = LinearEyeDepth(depth, _ZBufferParams);
        InterlockedMin(tileMinDepthInt, asuint(linearDepth));
        InterlockedMax(tileMaxDepthInt, asuint(linearDepth));
    }
    GroupMemoryBarrierWithGroupSync();

    float tileDepthMin = asfloat(tileMinDepthInt);
    float tileDepthMax = asfloat(tileMaxDepthInt);

    uint passCount = ceil((float)PointLightCount / THREADS_COUNT);
    uint2 tileId = groupId.xy;
    float tileDepthMinScale = tileDepthMin / _ProjectionParams.y;

    float3 tileFrustumCorners[4];
    tileFrustumCorners[0] = tileDepthMinScale * (_CameraNearPlaneLB + tileId.x * _CameraNearBasisH + tileId.y * _CameraNearBasisV);
    tileFrustumCorners[1] = tileFrustumCorners[0] + _CameraNearBasisH * tileDepthMinScale;
    tileFrustumCorners[2] = tileFrustumCorners[0] + (_CameraNearBasisH + _CameraNearBasisV) * tileDepthMinScale;
    tileFrustumCorners[3] = tileFrustumCorners[0] + _CameraNearBasisV * tileDepthMinScale;

    for (uint passIdx = 0; passIdx < passCount; passIdx++)
    {
        uint lightIndex = passIdx * THREADS_COUNT + groupIndex;
        if(lightIndex < PointLightCount)
        {
            float4 lightSphere = PointLightPositionsAndRadius[lightIndex];
            lightSphere.xyz = mul(unity_MatrixV, float4(lightSphere.xyz, 1.0));
            if(Intersect(tileFrustumCorners, lightIndex))
            {
                uint offset;
                InterlockedAdd(tileVisibleLightCount, 1, offset);
                tileVisibleLightsIndices[offset] = lightIndex;
            }
            
        }
    }

    GroupMemoryBarrierWithGroupSync();

    uint tileIndex = tileId.y * _DeferredTileParams.z + tileId.x;
    if(groupIndex == 0)
    {
        _RWTileLightsArgsBuffer[tileIndex] = tileVisibleLightCount;
    }
    if(groupIndex < tileVisibleLightCount && groupIndex < MAX_LIGHTS_PER_TILE)
    {
        uint visibleLightIndex = tileVisibleLightsIndices[groupIndex];
        _RWTileLightsIndicesBuffer[tileIndex * MAX_LIGHTS_PER_TILE + groupIndex] = visibleLightIndex;
    }
}