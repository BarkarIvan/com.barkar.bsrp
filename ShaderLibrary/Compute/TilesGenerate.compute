#pragma kernel TilesGenerate

#include "Packages/com.barkar.bsrp/ShaderLibrary/Common.hlsl"
#include "Packages/com.barkar.bsrp/ShaderLibrary/UnityInput.hlsl"


Texture2D<float> _DepthTexture : register(t1);
Texture2D<float3>_NormalTexture : register(t2);
RWTexture2D<float4> _DebugTexture : register(u1);

float4x4 _CameraProjection;

#define TILESIZE 16
#define TILE_GROUP_SIZE (TILESIZE * TILESIZE)


groupshared uint minDepthShared = 0xFFFFFFFF;
groupshared uint maxDepthShared = 0;

bool Intersects(float4 positionView, float radius, float4 frustumPlanes[6])
{
    bool inFrustum = true;
    [unroll] for (uint i = 0; i < 6; ++i)
    {
        float d = dot(frustumPlanes[i], float4(positionView.xyz, 1.0f));
        inFrustum = inFrustum && (d >= -radius);
    }
    return inFrustum;
}

[numthreads(TILESIZE, TILESIZE, 1)]
void TilesGenerate(uint3 gtid : SV_GroupThreadID, uint3 gid : SV_GroupID, uint groupIndex : SV_GroupIndex)
{
    uint2 textureSize;
    _DepthTexture.GetDimensions(textureSize.x, textureSize.y);

    float2 uv = (float2(gid.xy * TILESIZE + gtid.xy) + 0.5f) / textureSize;
    float depth = _DepthTexture.SampleLevel(sampler_point_clamp, uv, 0).r;
    depth = LinearEyeDepth(depth, _ZBufferParams);
    InterlockedMin(minDepthShared, asuint(depth));
    InterlockedMax(maxDepthShared, asuint(depth));

    GroupMemoryBarrierWithGroupSync();

    float minDepth = asfloat(minDepthShared);
    float maxDepth = asfloat(maxDepthShared);

    float2 tileScale = textureSize * rcp(float(2 * TILESIZE));
    float2 tileBias = tileScale - float2(gid.xy);

    float4 c1 = float4(UNITY_MATRIX_P._m00 * tileScale.x, 0.0f, -tileBias.x, 0.0f);
    float4 c2 = float4(0.0f, -UNITY_MATRIX_P._m11 * tileScale.y, -tileBias.y, 0.0f);
    float4 c4 = float4(0.0f, 0.0f, 1.0f, 0.0f);


    float4 frustumPlanes[6];
    frustumPlanes[0] = c4 - c1; // right
    frustumPlanes[1] = c1; // left
    frustumPlanes[2] = c4 - c2; // top
    frustumPlanes[3] = c2; // bottom
    frustumPlanes[4] = float4(0.0f, 0.0f, 1.0f, maxDepth);//far
    frustumPlanes[5] = float4(0.0f, 0.0f, -1.0f, -minDepth); // near

    [unroll] for (uint p = 0; p < 4; ++p)
    {
        frustumPlanes[p] *= rcp(length(frustumPlanes[p].xyz));
    }
    
    for (uint y = 0; y < TILESIZE; y++)
    {
        for (uint x = 0; x < TILESIZE; x++)
        {
            uint2 pixelCoord = gid.xy * TILESIZE + uint2(x, y);
            _DebugTexture[pixelCoord] = 0;
        }
    }

    for (uint lightIndex = groupIndex; lightIndex < PointLightCount; lightIndex += TILE_GROUP_SIZE)
    {
        float4 positionView = mul(UNITY_MATRIX_V, float4(PointLightPositionsAndRadius[lightIndex].xyz, 1.0));
       // positionView.xyz/=positionView.w;
        float r  = PointLightColors[lightIndex].w;

        bool intersects = Intersects(positionView, r, frustumPlanes);
            
        for (uint y = 0; y < TILESIZE; y++)
        {
            for (uint x = 0; x < TILESIZE; x++)
            {
                if (intersects)
                {
                    uint2 pixelCoord = gid.xy * TILESIZE + uint2(x, y);
                    _DebugTexture[pixelCoord] += float4(PointLightColors[lightIndex].rgb,1);
                }
            }
        }
    }
}
