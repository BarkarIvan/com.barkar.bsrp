#pragma kernel TilesGenerate

#include "Packages/com.barkar.bsrp/ShaderLibrary/Common.hlsl"
#include "Packages/com.barkar.bsrp/ShaderLibrary/UnityInput.hlsl"


Texture2D<float> _DepthTexture : register(t1);
RWTexture2D<float4> _DebugTexture : register(u2);
RWStructuredBuffer<int> _TileLightCountBuffer : register(u0);
RWStructuredBuffer<int> _TileLightIndicesBuffer : register(u1);


#define TILESIZE 16
#define TILE_GROUP_SIZE (TILESIZE * TILESIZE)



groupshared int minDepthShared = 0xFFFFFFFF;
groupshared int maxDepthShared = 0;

groupshared int tileVisibleLightIndices[MAX_LIGHT_COUNT];
groupshared int tileVisibleLightCount = 0;

bool Intersects(float4 positionView, float radius, float4 frustumPlanes[6])
{
    bool inFrustum = true;
    [unroll] for (int i = 0; i < 6; ++i)
    {
        float d = dot(frustumPlanes[i], float4(positionView.xyz, 1.0f));
        inFrustum = inFrustum && (d >= -radius);
    }
    return inFrustum;
}


[numthreads(TILESIZE, TILESIZE, 1)]
void TilesGenerate(int3 threadID : SV_GroupThreadID, int3 groupID : SV_GroupID, int groupIdx : SV_GroupIndex)
{
    int2 textureSize;
    _DepthTexture.GetDimensions(textureSize.x, textureSize.y);

    float2 uv = (float2(groupID.xy * TILESIZE + threadID.xy) + 0.5f) / textureSize;
    float depth = _DepthTexture.SampleLevel(sampler_point_clamp, uv, 0).r;
    depth = LinearEyeDepth(depth, _ZBufferParams);

    InterlockedMin(minDepthShared, asuint(depth));
    InterlockedMax(maxDepthShared, asuint(depth));

    
    for (int y = 0; y < TILESIZE; y++)
    {
        for (int x = 0; x < TILESIZE; x++)
        {
            int2 pixelCoord = groupID.xy * TILESIZE + uint2(x, y);
            _DebugTexture[pixelCoord] = 0;
        }
    }

    GroupMemoryBarrierWithGroupSync();

    float minDepth = asfloat(minDepthShared);
    float maxDepth = asfloat(maxDepthShared);

    float2 tileScale = textureSize * rcp(float(2 * TILESIZE));
    float2 tileBias = tileScale - float2(groupID.xy);

    float4 c1 = float4(UNITY_MATRIX_P._m00 * tileScale.x, 0.0f, -tileBias.x, 0.0f);
    float4 c2 = float4(0.0f, -UNITY_MATRIX_P._m11 * tileScale.y, -tileBias.y, 0.0f);
    float4 c4 = float4(0.0f, 0.0f, 1.0f, 0.0f);


    float4 frustumPlanes[6];
    frustumPlanes[0] = c4 - c1; // right
    frustumPlanes[1] = c1; // left
    frustumPlanes[2] = c4 - c2; // top
    frustumPlanes[3] = c2; // bottom
    frustumPlanes[4] = float4(0.0f, 0.0f, 1.0f, maxDepth); //far
    frustumPlanes[5] = float4(0.0f, 0.0f, -1.0f, -minDepth); // near

    [unroll] for (int p = 0; p < 4; ++p)
    {
        frustumPlanes[p] *= rcp(length(frustumPlanes[p].xyz));
    }


    for (int lightIndex = groupIdx; lightIndex < PointLightCount; lightIndex += TILE_GROUP_SIZE)
    {
        float r = PointLightColors[lightIndex].w;
        float4 positionView = mul(UNITY_MATRIX_V, float4(PointLightPositionsAndRadius[lightIndex].xyz, 1.0));
        positionView.xyz /= positionView.w;

        bool intersect = Intersects(positionView, r, frustumPlanes);
        if (intersect )
        {
            uint offset;
            InterlockedAdd(tileVisibleLightCount, 1, offset);
            tileVisibleLightIndices[offset] = lightIndex;

            
            for (int y = 0; y < TILESIZE; y++)
            {
                for (int x = 0; x < TILESIZE; x++)
                {
                   
                        int2 pixelCoord = groupID.xy * TILESIZE + uint2(x, y);
                        _DebugTexture[pixelCoord] += PointLightColors[lightIndex];
                }
            }
            
        }
    }
    GroupMemoryBarrierWithGroupSync();

    int tileIndex = groupID.y * (textureSize.x / TILESIZE) + groupID.x;

    if (groupIdx == 0) {
        _TileLightCountBuffer[tileIndex] = tileVisibleLightCount;
        int2 pixelCoord = groupID.xy * TILESIZE;
        _DebugTexture[pixelCoord] = float4(tileVisibleLightCount, 0,0, 1);
    }

    for (int i = groupIdx; i < tileVisibleLightCount && i < PER_TILE_LIGHT_COUNT; i += TILE_GROUP_SIZE)
    {
        _TileLightIndicesBuffer[tileIndex * PER_TILE_LIGHT_COUNT + i] = tileVisibleLightIndices[i];
    }
    
    /*
    for (uint y = 0; y < TILESIZE; y++)
    {
        for (uint x = 0; x < TILESIZE; x++)
        {
            if (intersects)
            {
                uint2 pixelCoord = gid.xy * TILESIZE + uint2(x, y);
                _DebugTexture[pixelCoord] = float4(PointLightColors[lightIndex].rgb,1);
            }
        }
    }
    */
}



